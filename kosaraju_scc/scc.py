class Scc(object):
    """
    Kosaraju's two-pass algorithm implementation

    Attributes
    ----------
        graph : dictionary
            represents edges of a directed graph, every node is a key, it's value is all its
            connected nodes with -/+ sign for incoming/outgoing edges
        sizes : list
            SCC sizes in order they found
        lists : list
            SCC components in order they found

    Methods
    -------
        add_edge(from_v, to_v)
            adds one edge to graph dictionary
        compute_order()
            first DFS pass on reversed graph, returns the order of nodes to be followed
            in reverse order by find_sccs method
        find_sccs():
            second DFS pass following the reverse order generated by compute_order method,
            returns SCC sizes and components lists
    """

    def __init__(self, adj_file):
        """
        reads text file represents graph edges and converts it to a dictionary represents every
        node in the graph and its incoming/outgoing edges

        Parameters
        ----------
        adj_file : text file
            adjacency list of a directed graph, each line is one edge represented as from-node
            followed by to-node, separated by a space

        Attributes
        ----------
        _graph : dictionary
            represents edges of a directed graph, every node is a key, it's value is all its
            connected nodes with -/+ sign for incoming/outgoing edges
        _sizes : list
            SCC sizes in order they found
        _lists : list
            SCC components in order they found
        _order : list
            the order of nodes generated by first DFS pass on reversed graph,
            which the second DFS pass needs to follow in reverse order to find SCCs
        """

        self._graph = {}
        self._order = []
        self._sizes = []
        self._lists = []
        with open(adj_file) as file:
            for line in file:
                (from_v, to_v) = tuple(number for number in line.split())
                self.add_edge(int(from_v), int(to_v))

    @property
    def graph(self):
        """Get graph"""
        return self._graph

    @property
    def sizes(self):
        """Get sizes"""
        return self._sizes

    @property
    def lists(self):
        """Get lists"""
        return self._lists

    def add_edge(self, from_v, to_v):
        """adds one edge to graph dictionary"""
        if from_v in self._graph:  # from_v is already in {}
            self._graph[from_v].append(to_v)  # append positive to_v (outward)
        else:
            self._graph[from_v] = [to_v]  # add from_v to {} with positive to_v (outward)
        if to_v in self._graph:  # to_v is already in {}
            self._graph[to_v].append(-from_v)  # append negative from_v (inward)
        else:
            self._graph[to_v] = [-from_v]  # add to_v to {} with negative from_v (inward)

    def compute_order(self):
        """
        first DFS pass on reversed graph, returns the order of nodes to be followed
        in reverse order by find_sccs method
        """

        visited_nodes = set()  # visited means neighbors explored already
        finished_nodes = set()  # finished means assigned finish order (appended to order list)
        for vertex in self._graph.keys():
            if vertex in visited_nodes:
                continue
            nodes_stack = [vertex]
            while nodes_stack:
                node = nodes_stack.pop()
                if node not in visited_nodes:  # append back, add to visited nodes, explore neighbors
                    nodes_stack.append(node)
                    visited_nodes.add(node)
                    neighbors = (-edge for edge in self._graph[node] if edge < 0)  # reverse transverse
                    for neighbor in neighbors:
                        if neighbor not in visited_nodes:
                            nodes_stack.append(neighbor)
                # visited and last in stack (has no neighbors or processed already)
                else:
                    if node not in finished_nodes:  # assigned finish order, add to finished nodes
                        self._order.append(node)
                        finished_nodes.add(node)

    def find_sccs(self, enable_lists=False):
        """
        second DFS pass following the reverse order generated by compute_order method,
        returns SCC sizes and components lists

        Parameters
        ----------
        enable_lists : boolean (False by default)
            if True, the algorithm populate SCC lists with one list per SCC contains its components
        """

        visited_nodes = set()
        assert (len(self._order) == len(self._graph))
        for i in reversed(self._order):
            if i in visited_nodes:
                continue
            nodes_stack = [i]
            scc_list = []  # list of all components related to node i
            size = 0  # size of scc related to node i
            while nodes_stack:
                node = nodes_stack.pop()
                if node not in visited_nodes:  # append back, add to visited nodes, explore neighbors
                    nodes_stack.append(node)
                    visited_nodes.add(node)
                    size += 1  # count toward size of scc related to node i
                    if enable_lists:
                        scc_list.append(node)  # append to scc related to node i
                    neighbors = (edge for edge in self._graph[node] if edge > 0)
                    for neighbor in neighbors:
                        if neighbor not in visited_nodes:
                            nodes_stack.append(neighbor)
            self._sizes.append(size)
            if enable_lists:
                self._lists.append(scc_list)

# driver test code
if __name__ == "__main__":
    print("Processing...")
    scc = Scc("scc_data.txt")
    scc.compute_order()
    scc.find_sccs(enable_lists=True)
    print("Testing...")

    # graph size test
    g_len1 = len(scc.graph)
    g_len2 = sum(scc.sizes)
    graph_size_test =  g_len1 == g_len2
    print("Graph size test OK" if graph_size_test else "Graph size test Failed!")

    # scc value test
    expected_sccs = [434821, 968, 459, 313, 211]  # top 5 scc sizes
    scc_head = sorted(scc.sizes, reverse=True)[:5]  # biggest scc first
    scc_value_test = scc_head == expected_sccs
    print("SCC value test OK" if scc_value_test else "SCC value test Failed!")


    # scc count test
    scc_count1 = len(scc.sizes)
    scc_count2 = len(scc.lists)
    scc_count_test = scc_count1 == scc_count2
    print("SCC count test OK" if scc_count_test else "SCC count test Failed!")

    # scc size test
    scc_list_size = [len(i) for i in scc.lists]  # scc sizes in scc_list
    scc_size_test = scc_list_size == scc.sizes
    print("SCC size test OK" if scc_size_test else "SCC size test Failed!")

    print("All tests OK" if graph_size_test and scc_value_test and scc_count_test and scc_size_test
          else "One or more tests Failed!")
